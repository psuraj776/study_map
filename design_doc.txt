1. High-Level Design Document
Project Name: Offline Interactive Atlas of India
Version: 1.0
Date: August 27, 2025

1.1. Introduction & Purpose
This document outlines the design for a cross-platform (Android & iOS) mobile application that provides users with an interactive, layered map of India. The application's primary feature is its full offline capability, ensuring that all core functionalities are available without an internet connection. The purpose is to create a reliable and fast tool for educational, travel, and research purposes, allowing users to explore India's geography with rich, thematic data overlays.

1.2. Scope
The application will deliver the following core features:

Hierarchical Navigation: Users will start at a national view of India and can navigate to state and district levels.

Interactive Map: The map will be pannable and zoomable at all levels.

Thematic Layers: Users can toggle the visibility of various data layers, including political boundaries (states, districts), geographical features (rivers), and potentially others in the future (e.g., historical sites, national parks).

Offline First: All map data, including the basemap and vector layers, will be bundled with the application for a complete offline experience.

Premium Features & Subscription: The app will offer an optional premium subscription that unlocks advanced features (e.g., additional map layers, functionality). This will be handled via the native Google Play Store and Apple App Store billing systems.

1.3. Non-Functional Requirements
Platform: The app must be built from a single codebase for both Android and iOS.

1.4. User & Subscription Management (New Section)
Authentication: The application will not have a traditional email/password login system. A user's identity and subscription status are tied directly to their Google or Apple account used for the app store.

Subscription Verification: The "source of truth" for a user's subscription is the respective app store. The app will query the store's billing service on launch (when online) to verify an active subscription. This status will then be cached locally on the device, allowing premium features to work offline.

Cross-Device Access: A user who purchases a subscription can access premium features on any device logged into the same Google/Apple account by using a "Restore Purchases" function within the app.

Performance: The user interface, especially map rendering and interaction, must be smooth and responsive.

Maintainability: The architecture must be modular to allow for easy updates to map data and the addition of new features.

2. Architecture Document
2.1. Technology Stack
Cross-Platform Framework: Flutter (using Dart) is chosen for its high-performance rendering and ability to build for both iOS and Android from a single codebase.

Data Preparation Tool: QGIS (Desktop) is the designated tool for preparing all geographic data. It is used to edit, style, and export vector layers and to generate the offline raster basemap.

State Management: Flutter Riverpod is used to manage the application's state in a clean, scalable, and reactive way. It handles UI state (like layer visibility) and the asynchronous loading of data.

In-App Purchases: The official in_app_purchase Flutter package will be used to handle all communication with the Google Play and Apple App Store billing services.

2.2. Data Architecture
The application relies on two primary types of offline data, both prepared in QGIS and stored in the app's assets directory.

Offline Basemap (.mbtiles): A raster tile set generated from a source like OpenStreetMap. This provides the visual background context (land, water, major cities) and is loaded using the flutter_map_tile_caching package.

Vector Layers (.geojson): Lightweight, text-based files that define the interactive shapes. Each layer (states, districts, rivers) is a separate .geojson file. This format is chosen for its ease of parsing and rendering.

2.3. Software Architecture
The application follows a clean, three-tiered architecture:

Data Layer (providers.dart):

Providers: Riverpod FutureProviders are used to asynchronously load and parse each .geojson file from the app's assets. This keeps the data loading logic separate from the UI and caches the results efficiently.

Data Models: The geojson_vi package implicitly handles the data models, parsing the GeoJSON text into structured Dart objects.

State/Business Logic Layer (providers.dart):

StateNotifier: A Riverpod StateNotifier (LayerVisibility) is used to manage the UI state. It holds a map of layer IDs to boolean flags (e.g., {'states': true, 'rivers': false}) and provides methods to toggle them. This ensures that any change in state automatically triggers a UI rebuild only where needed.

Presentation/UI Layer (main.dart):

ConsumerWidget: All UI components that need to display or change state are ConsumerWidgets, allowing them to listen to providers.

FlutterMap: The core widget for displaying the map. Its children list is built dynamically based on the state from the providers.

TileLayer: Renders the offline .mbtiles basemap.

PolygonLayer / PolylineLayer: These layers are conditionally added to the map based on the layerVisibilityProvider. Their data comes from the respective FutureProviders (statesProvider, riversProvider).

Controls: UI elements like CheckboxListTile read the current state from layerVisibilityProvider and call methods on its notifier to update the state when tapped.
Data Layer (providers.dart / services/):

New Component: A PurchaseService will be created. This service will encapsulate all logic related to the in_app_purchase package. Its responsibilities include:

Initializing the connection to the app store.

Fetching product details (e.g., price).

Initiating the purchase flow.

Verifying and processing purchase updates.

Caching the premium status to local device storage (e.g., using shared_preferences).

State/Business Logic Layer (providers.dart):

New Component: A new Riverpod provider, premiumStatusProvider, will be created. This provider will hold the current boolean status of the user's subscription (true or false). It will be updated by the PurchaseService and watched by the UI.

Presentation/UI Layer (main.dart):

New Components: The UI will be updated to include:

A "Go Premium" button or screen that is shown to non-premium users.

A "Restore Purchases" button in the settings.

Logic within the map's control panel to conditionally show/hide premium layers based on the state of the premiumStatusProvider.

3. Functionality Document (User Guide)
Welcome to the Offline Interactive Atlas of India!

This guide will help you use the app's features to explore the map.

3.1. Basic Navigation
Pan: Touch and drag anywhere on the map to move it around.

Zoom: Use a two-finger pinch gesture to zoom in and out.

3.2. Using the Layer Controls
On the map screen, you will find a control panel with a list of available map layers.

Show a Layer: Tap the checkbox next to a layer's name to make it visible on the map.

Hide a Layer: Tap the checkbox again to hide the layer.

You can have multiple layers visible at the same time to see how different features relate to each other.

4. Support & Maintenance Document
This document provides guidance for developers on how to maintain and update the application.

4.1. Updating Map Data
The most common maintenance task will be updating the geographic data.

To update an existing layer (e.g., new district boundaries):

Open the source Shapefile or GeoPackage in QGIS.

Use the editing tools (Split Features, Merge Features, Vertex Tool) to make the necessary changes to the shapes.

Update the corresponding information in the Attribute Table.

Save the layer edits in QGIS.

Export the updated layer as a .geojson file, overwriting the old version.

Replace the corresponding file in the Flutter project's assets/layers directory.

Rebuild the app.

To add a new layer:

Prepare the new layer in QGIS and export it as a .geojson file.

Add the new file to the assets/layers folder in the Flutter project.

In providers.dart, create a new FutureProvider to load and parse this new file (similar to statesProvider).

In providers.dart, add a new entry for the layer in the LayerVisibility StateNotifier.

In main.dart, add a new CheckboxListTile to the control panel to toggle the new layer's visibility.

In main.dart, conditionally add the new PolygonLayer or PolylineLayer to the FlutterMap widget, based on its visibility state.

4.2. Troubleshooting
App crashes on startup: This is often due to a missing or misnamed asset file. Verify that the file paths in the code (e.g., 'assets/basemaps/india_basemap.mbtiles') exactly match the file names and locations in the assets folder. Also, ensure pubspec.yaml has been updated to include the asset paths.

Map is blank: This can happen if the .mbtiles file is corrupted or could not be loaded. Check the debug console for any errors related to TileCache.mbtiles.

Vector layers don't appear: This is usually caused by malformed .geojson files or errors during parsing. Check the debug console for any JSON parsing errors. Ensure the GeoJSON file is valid and contains the correct geometry types (Polygons, LineStrings, etc.).

4.3. Managing In-App Purchases (New Section)
Store Setup: The premium subscription itself (e.g., product ID premium_features_yearly, price, duration) must be created and managed in the Google Play Console for the Android app and App Store Connect for the iOS app. These IDs must match the ones used in the application code.

Troubleshooting Common Issues:

User's purchase is not recognized: Instruct the user to ensure they are logged into the same store account they used to make the purchase. Guide them to use the "Restore Purchases" button, which forces the app to re-query the app store for their active subscriptions.

"Product not found" error: This typically means there is a mismatch between the product ID in the code and the one set up in the Google Play Console / App Store Connect, or the product has not been approved for sale yet.



ğŸ“ Directory Structure Explanation
Let me explain the purpose and contents of each directory in your Flutter offline map app:

ğŸ—ï¸ Root Level
main.dart
Purpose: Entry point of the Flutter application
Contains:
main() function that starts the app
ProviderScope for Riverpod state management
Root MaterialApp widget configuration
ğŸ§  core/ - Application Foundation
The core directory contains shared functionality used throughout the app.

constants/ - Static Data & Configuration

//Â WhatÂ itÂ contains:dev_config.dartÂ Â Â Â Â Â Â Â Â //Â DevelopmentÂ settingsÂ andÂ featureÂ flagsgeographic_data.dartÂ Â Â Â //Â StaticÂ geographicÂ dataÂ (states,Â districts,Â bounds)map_constants.dartÂ Â Â Â Â Â //Â Map-relatedÂ constantsÂ (zoomÂ levels,Â centers)
Purpose: Centralized configuration and static data
Examples: Default zoom levels, India's geographic boundaries, dev mode settings
controllers/ - Business Logic Controllers

//Â WhatÂ itÂ contains:map_navigation_controller.dartÂ Â //Â HandlesÂ mapÂ navigationÂ stateÂ changes
Purpose: Contains Riverpod StateNotifiers that manage app state
Responsibilities: State transitions, business logic, API calls coordination
models/ - Data Models

//Â WhatÂ itÂ contains:layer_models.dartÂ Â Â Â Â Â Â Â Â Â Â //Â LayerÂ configurationÂ dataÂ modelsmap_navigation_state.dartÂ Â Â //Â MapÂ navigationÂ stateÂ model
Purpose: Define data structures used throughout the app
Contains: Classes, enums, and data transfer objects
providers/ - State Management

//Â WhatÂ itÂ contains:app_providers.dartÂ Â Â Â Â Â //Â GlobalÂ app-wideÂ providerslayer_providers.dartÂ Â Â Â //Â Layer-specificÂ stateÂ providers
Purpose: Riverpod providers for dependency injection and state management
Contains: Provider definitions that connect services to UI
utils/ - Utility Functions

//Â WhatÂ itÂ contains:asset_utils.dartÂ Â Â Â Â Â Â Â Â //Â AssetÂ pathÂ helperspolygon_extensions.dartÂ Â //Â PolygonÂ manipulationÂ utilities
Purpose: Reusable helper functions and extensions
Contains: Pure functions, extensions, and utility classes
ğŸ¯ features/ - Feature-Based Architecture
Each feature is self-contained with its own presentation, domain, and data layers.

auth/ - Authentication Feature

auth/â”œâ”€â”€Â presentation/â”‚Â Â Â â””â”€â”€Â screens/â”‚Â Â Â Â Â Â Â â””â”€â”€Â login_screen.dartÂ Â //Â DeviceÂ authorizationÂ UI
Purpose: Handles device authentication and authorization
Contains: Login screens, auth widgets, auth-related UI logic
map/ - Map Feature (Main Feature)

map/â”œâ”€â”€Â domain/â”‚Â Â Â â””â”€â”€Â repositories/â”‚Â Â Â Â Â Â Â â””â”€â”€Â map_repository.dartÂ Â Â Â Â //Â MapÂ dataÂ accessÂ layerâ””â”€â”€Â presentation/Â Â Â Â â”œâ”€â”€Â screens/Â Â Â Â â”‚Â Â Â â””â”€â”€Â map_screen.dartÂ Â Â Â Â Â Â Â Â //Â MainÂ mapÂ screenÂ Â Â Â â””â”€â”€Â widgets/Â Â Â Â Â Â Â Â â”œâ”€â”€Â layer_menu_button.dartÂ Â //Â LayerÂ toggleÂ buttonÂ Â Â Â Â Â Â Â â”œâ”€â”€Â layer_menu.dartÂ Â Â Â Â Â Â Â Â //Â LayerÂ selectionÂ menuÂ Â Â Â Â Â Â Â â””â”€â”€Â map_widget.dartÂ Â Â Â Â Â Â Â Â //Â CoreÂ mapÂ widget
domain/repositories/ - Data Access
Purpose: Abstract data access and business rules
Contains: Repository interfaces and implementations
Responsibilities: GeoJSON loading, polygon processing, data caching
presentation/ - UI Layer
screens/: Full-screen widgets (pages)
widgets/: Reusable UI components
Purpose: User interface and user interaction handling
âš™ï¸ services/ - External Services
Contains services that interact with external systems or provide app-wide functionality.

Service Files

app_logger.dartÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â //Â LoggingÂ serviceoffline_subscription_service.dartÂ //Â SubscriptionÂ managementsecure_device_service.dartÂ Â Â Â Â Â Â //Â DeviceÂ securityÂ service
app_logger.dart
Purpose: Centralized logging system
Contains: Debug, info, warning, error logging methods
Features: Performance tracking, event logging
offline_subscription_service.dart
Purpose: Manages user subscriptions and premium features
Contains: Subscription validation, feature access control
Features: Premium activation, subscription status checking
secure_device_service.dart
Purpose: Device authorization and security
Contains: Device registration, validation, logout functionality
Features: Device integrity checks, authorization management
ğŸ›ï¸ Architecture Pattern: Clean Architecture + Feature-First
Layer Separation:

ğŸ“±Â PresentationÂ LayerÂ (UI)Â Â Â Â â†“ğŸ§ Â DomainÂ LayerÂ (BusinessÂ Logic)Â Â Â Â â†“ğŸ’¾Â DataÂ LayerÂ (Services/Repositories)
Dependency Flow:

UIÂ ComponentsÂ â†’Â ProvidersÂ â†’Â ControllersÂ â†’Â Services/Repositories
Benefits:
ğŸ”’ Separation of Concerns: Each directory has a specific responsibility
ğŸ”„ Reusability: Core utilities and services are shared
ğŸ§ª Testability: Each layer can be tested independently
ğŸ“ˆ Scalability: Easy to add new features without affecting existing code
ğŸ› ï¸ Maintainability: Clear structure makes debugging and updates easier
Data Flow Example:

UserÂ tapsÂ mapÂ â†’Â map_widget.dartÂ â†’Â map_navigation_controller.dartÂ â†’Â map_repository.dartÂ â†’Â geographic_data.dart
This structure follows Flutter best practices and makes your app:

Modular: Features are independent
Scalable: Easy to add new features
Maintainable: Clear separation of concerns
Testable: Each part can be tested in isolation
